<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BANDIT - AprilTag Detection System</title>
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: #f8fafc;
            color: #334155;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1440px;
            margin: 0 auto;
            background: #ffffff;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .header {
            background: #ffffff;
            border-bottom: 1px solid #e2e8f0;
            padding: 24px 32px;
        }
        
        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .brand-section {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .logo {
            width: 48px;
            height: 48px;
            background: #1e293b;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: #ffffff;
            font-size: 18px;
        }
        
        .brand-info h1 {
            font-size: 24px;
            font-weight: 700;
            color: #0f172a;
            margin-bottom: 2px;
        }
        
        .company-name {
            font-size: 14px;
            color: #64748b;
            font-weight: 500;
        }
        
        .header-meta {
            text-align: right;
        }
        
        .version {
            font-size: 12px;
            color: #64748b;
            margin-bottom: 4px;
        }
        
        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 14px;
            font-weight: 500;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #22c55e;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 400px;
            background: #f8fafc;
        }
        
        .video-section {
            padding: 32px;
            background: #ffffff;
            border-right: 1px solid #e2e8f0;
        }
        
        .video-container {
            position: relative;
            background: #000000;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            margin-bottom: 24px;
            border: 1px solid #e2e8f0;
        }
        
        #videoFeed {
            width: 100%;
            height: auto;
            display: block;
            max-width: 100%;
        }
        
        .video-overlay {
            position: absolute;
            top: 16px;
            right: 16px;
            background: rgba(0, 0, 0, 0.75);
            color: #ffffff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            font-family: 'Inter', monospace;
        }
        
        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .btn {
            background: #1e293b;
            color: #ffffff;
            border: 1px solid #334155;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            font-family: 'Inter', sans-serif;
            transition: all 0.2s ease;
        }
        
        .btn:hover {
            background: #334155;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        
        .btn:active {
            transform: translateY(1px);
        }
        
        .btn.primary {
            background: #3b82f6;
            border-color: #2563eb;
        }
        
        .btn.primary:hover {
            background: #2563eb;
        }
        
        .status {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .status.connected {
            background: #dcfce7;
            color: #166534;
            border: 1px solid #bbf7d0;
        }
        
        .status.disconnected {
            background: #fef2f2;
            color: #991b1b;
            border: 1px solid #fecaca;
        }
        
        .sidebar {
            background: #f8fafc;
            padding: 32px 24px;
            overflow-y: auto;
        }
        
        .info-panel {
            background: #ffffff;
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 24px;
            border: 1px solid #e2e8f0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .info-panel h3 {
            margin: 0 0 16px 0;
            color: #0f172a;
            font-size: 16px;
            font-weight: 600;
        }
        
        .tag-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .tag-list::-webkit-scrollbar {
            width: 6px;
        }
        
        .tag-list::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }
        
        .tag-list::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }
        
        .tag-item {
            background: #f8fafc;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            border: 1px solid #e2e8f0;
            transition: all 0.2s ease;
        }
        
        .tag-item:hover {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            border-color: #cbd5e1;
        }
        
        .tag-id {
            font-size: 14px;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 12px;
        }
        
        .tag-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 13px;
            color: #64748b;
        }
        
        .tag-info span {
            display: block;
            margin-bottom: 4px;
        }
        
        .tag-info strong {
            color: #374151;
            font-weight: 500;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }
        
        .stat-card {
            background: #f8fafc;
            border-radius: 8px;
            padding: 16px;
            text-align: center;
            border: 1px solid #e2e8f0;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #1e293b;
            display: block;
            font-family: 'Inter', monospace;
        }
        
        .stat-label {
            color: #64748b;
            font-size: 12px;
            margin-top: 4px;
            font-weight: 500;
        }
        
        .coordinates {
            font-family: 'Inter', monospace;
            font-size: 12px;
            background: #f1f5f9;
            padding: 12px;
            border-radius: 6px;
            margin-top: 12px;
            border: 1px solid #e2e8f0;
            color: #475569;
        }
        
        .collapsible-panel {
            margin-bottom: 24px;
        }
        
        .panel-header {
            background: #f1f5f9;
            border: 1px solid #e2e8f0;
            border-radius: 8px 8px 0 0;
            padding: 12px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: background-color 0.2s ease;
        }
        
        .panel-header:hover {
            background: #e2e8f0;
        }
        
        .panel-header.collapsed {
            border-radius: 8px;
        }
        
        .panel-title {
            font-size: 14px;
            font-weight: 600;
            color: #1e293b;
        }
        
        .panel-chevron {
            width: 16px;
            height: 16px;
            transition: transform 0.2s ease;
            color: #64748b;
        }
        
        .panel-chevron.expanded {
            transform: rotate(180deg);
        }
        
        .panel-content {
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-top: none;
            border-radius: 0 0 8px 8px;
            padding: 16px;
            display: none;
        }
        
        .panel-content.expanded {
            display: block;
        }
        
        .camera-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .camera-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            transition: all 0.2s ease;
        }
        
        .camera-item:hover {
            background: #f1f5f9;
        }
        
        .camera-item.active {
            background: #dbeafe;
            border-color: #3b82f6;
        }
        
        .camera-info {
            flex: 1;
        }
        
        .camera-name {
            font-weight: 500;
            color: #1e293b;
            font-size: 14px;
        }
        
        .camera-details {
            font-size: 12px;
            color: #64748b;
            margin-top: 2px;
        }
        
        .camera-actions {
            display: flex;
            gap: 8px;
        }
        
        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 4px;
        }
        
        .current-badge {
            background: #22c55e;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #cbd5e1;
            transition: .3s;
            border-radius: 24px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: #3b82f6;
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        
        .detection-controls input[type="range"] {
            width: 100%;
            margin: 4px 0;
        }
        
        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .video-section {
                border-right: none;
                border-bottom: 1px solid #e2e8f0;
            }
        }
        
        @media (max-width: 768px) {
            .header {
                padding: 16px 20px;
            }
            
            .header-content {
                flex-direction: column;
                gap: 16px;
                align-items: flex-start;
            }
            
            .video-section {
                padding: 20px;
            }
            
            .sidebar {
                padding: 20px 16px;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-content">
                <div class="brand-section">
                    <div class="logo">B</div>
                    <div class="brand-info">
                        <h1>BANDIT</h1>
                        <div class="company-name">Dark Matter Labs</div>
                    </div>
                </div>
                <div class="header-meta">
                    <div class="version">Version 2.1.0</div>
                    <div class="status-indicator">
                        <div class="status-dot"></div>
                        System Operational
                    </div>
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="video-section">
                <div class="video-container">
                    <img id="videoFeed" src="/video_feed" alt="Video Feed">
                    <canvas id="measurementCanvas" style="position: absolute; top: 0; left: 0; pointer-events: none; z-index: 2;"></canvas>
                    <div class="video-overlay">
                        <span id="fps">FPS: --</span>
                        <div id="measurementInfo" style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 8px; border-radius: 4px; font-size: 12px; display: none;">
                            <div id="measurementText"></div>
                            <div style="margin-top: 4px;">
                                <button onclick="clearMeasurement()" style="background: #ef4444; border: none; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; cursor: pointer;">Clear</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="controls">
                    <button class="btn primary" onclick="startDetection()">Start Detection</button>
                    <button class="btn" onclick="stopDetection()">Stop Detection</button>
                    <button class="btn" onclick="calibrateCamera()">Calibrate Camera</button>
                    <button class="btn" id="measureBtn" onclick="toggleMeasurement()" disabled title="Calibrate camera first">📏 Measure</button>
                    <div class="status" id="connectionStatus">Connecting...</div>
                </div>
            </div>
            
            <div class="sidebar">
                <div class="collapsible-panel">
                    <div class="panel-header collapsed" onclick="togglePanel('cameraOptions')">
                        <span class="panel-title">Camera Options</span>
                        <svg class="panel-chevron" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </div>
                    <div class="panel-content" id="cameraOptions">
                        <div class="camera-list" id="cameraList">
                            <div style="text-align: center; color: #64748b; padding: 20px;">
                                Loading cameras...
                            </div>
                        </div>
                        <button class="btn btn-small" onclick="refreshCameras()" style="margin-top: 12px; width: 100%;">
                            Refresh Camera List
                        </button>
                    </div>
                </div>
                
                <div class="collapsible-panel">
                    <div class="panel-header collapsed" onclick="togglePanel('objectDetection')">
                        <span class="panel-title">Object Detection</span>
                        <svg class="panel-chevron" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </div>
                    <div class="panel-content" id="objectDetection">
                        <div class="detection-controls">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
                                <span style="font-weight: 500;">Enable Object Detection</span>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="objectDetectionToggle" onchange="toggleObjectDetection()">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            
                            <div id="objectDetectionConfig" style="display: none;">
                                <div style="margin-bottom: 16px;">
                                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                                        <button class="btn btn-small primary" id="startInferenceBtn" onclick="startMLInference()" style="flex: 1;">
                                            Start Inference
                                        </button>
                                        <button class="btn btn-small" id="stopInferenceBtn" onclick="stopMLInference()" style="flex: 1; display: none;">
                                            Stop Inference
                                        </button>
                                    </div>
                                    <div id="inferenceStatus" style="text-align: center; font-size: 12px; color: #64748b; margin-bottom: 12px;">
                                        Ready to start ML inference
                                    </div>
                                </div>
                                
                                <div style="margin-bottom: 12px;">
                                    <label style="display: block; margin-bottom: 4px; font-size: 13px; color: #374151;">Confidence Threshold</label>
                                    <input type="range" id="confidenceSlider" min="0.1" max="1.0" step="0.05" value="0.5" oninput="updateConfidence(this.value)">
                                    <span id="confidenceValue" style="font-size: 12px; color: #64748b;">0.5</span>
                                </div>
                                
                                <div style="margin-bottom: 12px;">
                                    <label style="display: block; margin-bottom: 4px; font-size: 13px; color: #374151;">NMS Threshold</label>
                                    <input type="range" id="nmsSlider" min="0.1" max="0.9" step="0.05" value="0.4" oninput="updateNMS(this.value)">
                                    <span id="nmsValue" style="font-size: 12px; color: #64748b;">0.4</span>
                                </div>
                                
                                <button class="btn btn-small primary" onclick="applyDetectionConfig()" style="width: 100%;">
                                    Apply Settings
                                </button>
                            </div>
                            
                            <div id="objectDetectionStatus" style="margin-top: 12px;">
                                <div style="font-size: 12px; color: #64748b;">
                                    <div>Status: <span id="detectionStatusText">Loading...</span></div>
                                    <div>Model: <span id="detectionModelText">RF-DETR</span></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="info-panel">
                    <h3>Detection Statistics</h3>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <span class="stat-value" id="tagCount">0</span>
                            <div class="stat-label">Tags Detected</div>
                        </div>
                        <div class="stat-card">
                            <span class="stat-value" id="objectCount">0</span>
                            <div class="stat-label">Objects Detected</div>
                        </div>
                        <div class="stat-card">
                            <span class="stat-value" id="avgDistance">--</span>
                            <div class="stat-label">Avg Distance (m)</div>
                        </div>
                        <div class="stat-card">
                            <span class="stat-value" id="avgConfidence">--</span>
                            <div class="stat-label">Avg Confidence</div>
                        </div>
                    </div>
                </div>
                
                <div class="info-panel">
                    <h3>Detected Tags</h3>
                    <div class="tag-list" id="tagList">
                        <p style="text-align: center; color: #64748b; margin: 20px 0;">No tags detected</p>
                    </div>
                </div>
                
                <div class="info-panel">
                    <h3>Detected Objects</h3>
                    <div class="tag-list" id="objectList">
                        <p style="text-align: center; color: #64748b; margin: 20px 0;">No objects detected</p>
                    </div>
                </div>
                
                <div class="info-panel" id="measurementPanel" style="display: none;">
                    <h3>Manual Measurement</h3>
                    <div style="margin-bottom: 16px;">
                        <div style="font-size: 13px; color: #64748b; margin-bottom: 12px;">
                            Click and drag on the video to measure distances. Camera calibration required.
                        </div>
                        <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                            <label style="display: flex; align-items: center; gap: 4px; font-size: 13px;">
                                <input type="radio" name="measurementUnit" value="metric" checked>
                                Metric (mm/m)
                            </label>
                            <label style="display: flex; align-items: center; gap: 4px; font-size: 13px;">
                                <input type="radio" name="measurementUnit" value="imperial">
                                Imperial (in/ft)
                            </label>
                        </div>
                        <div id="calibrationStatus" style="font-size: 12px; padding: 8px; border-radius: 4px; background: #fef2f2; color: #991b1b; border: 1px solid #fecaca;">
                            ⚠️ Camera not calibrated. Use "Calibrate Camera" first.
                        </div>
                        <div id="measurementResults" style="display: none; margin-top: 12px;">
                            <div style="background: #f0f9ff; border: 1px solid #bae6fd; border-radius: 6px; padding: 12px;">
                                <div style="font-size: 14px; font-weight: 600; margin-bottom: 8px; color: #0c4a6e;">Measurement Results</div>
                                <div id="measurementValues" style="font-size: 13px; color: #374151;"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="info-panel">
                    <h3>System Configuration</h3>
                    <div style="font-size: 13px; color: #64748b; line-height: 1.5;">
                        <p><strong style="color: #374151;">Camera Resolution:</strong> <span id="cameraInfo">640×480</span></p>
                        <p><strong style="color: #374151;">Detection Families:</strong> tag36h11, tag25h9</p>
                        <p><strong style="color: #374151;">Tag Size:</strong> 6.0" × 6.0"</p>
                        <p><strong style="color: #374151;">Pose Algorithm:</strong> PnP + Rodrigues</p>
                        <p><strong style="color: #374151;">Coordinate System:</strong> Right-handed (X, Y, Z)</p>
                        <p><strong style="color: #374151;">Measurement Units:</strong> Meters, Degrees, PPI</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        let isDetecting = false;
        let frameCount = 0;
        let lastFpsUpdate = Date.now();

        // Socket event handlers
        socket.on('connect', function() {
            document.getElementById('connectionStatus').textContent = 'Connected';
            document.getElementById('connectionStatus').className = 'status connected';
        });

        socket.on('disconnect', function() {
            document.getElementById('connectionStatus').textContent = 'Disconnected';
            document.getElementById('connectionStatus').className = 'status disconnected';
        });

        socket.on('frame_data', function(data) {
            if (data.image) {
                updateVideoFeed(data.image);
            }
            if (data.tags || data.objects) {
                updateTagInfo(data.tags || [], data.objects || []);
            }
            updateFPS();
        });

        socket.on('calibration_result', function(data) {
            if (data.success) {
                showNotification('Success', data.message, 'success');
                if (data.calibration_data) {
                    console.log('Calibration saved:', data.calibration_data);
                    // Update UI to show calibration is complete
                    updateCalibrationStatus(data.calibration_data);
                }
            } else {
                showNotification('Calibration Failed', data.message, 'error');
            }
        });

        socket.on('camera_switch_result', function(data) {
            if (data.success) {
                showNotification('Camera Switched', data.message, 'success');
                // Refresh camera list to update current camera
                loadCameras();
            } else {
                showNotification('Camera Switch Failed', data.message, 'error');
            }
        });

        socket.on('object_detection_toggle_result', function(data) {
            if (data.success) {
                showNotification('Object Detection', data.message, 'success');
                updateObjectDetectionStatus(data);
            } else {
                showNotification('Object Detection Error', data.message, 'error');
            }
        });

        socket.on('ml_inference_result', function(data) {
            if (data.success) {
                showNotification('ML Inference', data.message, 'success');
                updateInferenceButtons(data.running);
                updateInferenceStatus(data.running);
            } else {
                showNotification('ML Inference Error', data.message, 'error');
                updateInferenceButtons(false);
                updateInferenceStatus(false, data.message);
            }
        });

        function updateVideoFeed(imageData) {
            // The video feed is handled by the /video_feed route
            // This function could be used for WebSocket-based streaming if needed
        }

        function updateTagInfo(tags = [], objects = []) {
            const tagCount = document.getElementById('tagCount');
            const objectCount = document.getElementById('objectCount');
            const tagList = document.getElementById('tagList');
            const objectList = document.getElementById('objectList');
            const avgDistance = document.getElementById('avgDistance');
            const avgConfidence = document.getElementById('avgConfidence');

            // Update tag statistics
            tagCount.textContent = tags.length;
            objectCount.textContent = objects.length;

            if (tags.length === 0) {
                tagList.innerHTML = '<p style="text-align: center; color: #64748b; margin: 20px 0;">No tags detected</p>';
                avgDistance.textContent = '--';
            } else {
                // Calculate average distance
                const totalDistance = tags.reduce((sum, tag) => sum + tag.distance, 0);
                const average = totalDistance / tags.length;
                avgDistance.textContent = average.toFixed(3);

                // Update tag list
                tagList.innerHTML = '';
                tags.forEach(tag => {
                    const tagElement = createTagElement(tag);
                    tagList.appendChild(tagElement);
                });
            }

            if (objects.length === 0) {
                objectList.innerHTML = '<p style="text-align: center; color: #64748b; margin: 20px 0;">No objects detected</p>';
                if (avgConfidence) avgConfidence.textContent = '--';
            } else {
                // Calculate average confidence
                const totalConfidence = objects.reduce((sum, obj) => sum + obj.confidence, 0);
                const averageConf = totalConfidence / objects.length;
                if (avgConfidence) avgConfidence.textContent = averageConf.toFixed(3);

                // Update object list
                objectList.innerHTML = '';
                objects.forEach(obj => {
                    const objectElement = createObjectElement(obj);
                    objectList.appendChild(objectElement);
                });
            }
        }

        function createTagElement(tag) {
            const div = document.createElement('div');
            div.className = 'tag-item';
            
            const euler = tag.pose.euler_angles;
            const translation = tag.pose.translation;
            
            div.innerHTML = `
                <div class="tag-id">Tag ID: ${tag.id} (${tag.family})</div>
                <div class="tag-info">
                    <span><strong>Family:</strong> ${tag.family}</span>
                    <span><strong>Distance:</strong> ${tag.distance.toFixed(3)}m</span>
                    <span><strong>Center:</strong> (${Math.round(tag.center[0])}, ${Math.round(tag.center[1])})</span>
                    <span><strong>Roll:</strong> ${euler[0].toFixed(1)}°</span>
                    <span><strong>Pitch:</strong> ${euler[1].toFixed(1)}°</span>
                    <span><strong>Yaw:</strong> ${euler[2].toFixed(1)}°</span>
                    <span><strong>X:</strong> ${translation[0].toFixed(3)}m</span>
                    <span><strong>Y:</strong> ${translation[1].toFixed(3)}m</span>
                    <span><strong>Z:</strong> ${translation[2].toFixed(3)}m</span>
                    <span><strong>PPI:</strong> ${tag.pixels_per_inch.average.toFixed(1)}</span>
                    <span><strong>Tag Size:</strong> ${Math.round(tag.pixels_per_inch.tag_width_pixels)}×${Math.round(tag.pixels_per_inch.tag_height_pixels)}px</span>
                </div>
                <div class="coordinates">
                    Position: [${translation.map(v => v.toFixed(3)).join(', ')}]<br>
                    Rotation: [${euler.map(v => v.toFixed(1)).join(', ')}]°<br>
                    PPI: W=${tag.pixels_per_inch.width.toFixed(1)}, H=${tag.pixels_per_inch.height.toFixed(1)}
                </div>
            `;
            
            return div;
        }

        function updateFPS() {
            frameCount++;
            const now = Date.now();
            if (now - lastFpsUpdate >= 1000) {
                const fps = Math.round(frameCount * 1000 / (now - lastFpsUpdate));
                document.getElementById('fps').textContent = `FPS: ${fps}`;
                frameCount = 0;
                lastFpsUpdate = now;
            }
        }

        function startDetection() {
            isDetecting = true;
            // The detection is continuous via the video feed
            console.log('Detection started');
        }

        function stopDetection() {
            isDetecting = false;
            console.log('Detection stopped');
        }

        function calibrateCamera() {
            // Disable the button during calibration
            const calibrateBtn = document.querySelector('button[onclick="calibrateCamera()"]');
            const originalText = calibrateBtn.textContent;
            calibrateBtn.disabled = true;
            calibrateBtn.textContent = 'Calibrating...';
            
            // Send calibration request
            socket.emit('calibrate_camera');
            
            // Re-enable button after a delay
            setTimeout(() => {
                calibrateBtn.disabled = false;
                calibrateBtn.textContent = originalText;
            }, 3000);
        }

        function showNotification(title, message, type) {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 16px 20px;
                border-radius: 8px;
                color: white;
                font-weight: 500;
                max-width: 400px;
                z-index: 1000;
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
                background: ${type === 'success' ? '#22c55e' : '#ef4444'};
            `;
            
            notification.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 4px;">${title}</div>
                <div style="font-size: 14px; opacity: 0.9;">${message}</div>
            `;
            
            document.body.appendChild(notification);
            
            // Remove after 5 seconds
            setTimeout(() => {
                notification.remove();
            }, 5000);
        }

        function updateCalibrationStatus(calibrationData) {
            // Update system info to show current calibration
            const systemInfo = document.querySelector('.info-panel:last-child div');
            const ppiInfo = document.createElement('p');
            ppiInfo.innerHTML = `<strong style="color: #374151;">Current Calibration:</strong> ${calibrationData.pixels_per_inch.toFixed(2)} PPI (${calibrationData.tags_used} tags)`;
            ppiInfo.style.color = '#22c55e';
            ppiInfo.style.fontWeight = '500';
            systemInfo.appendChild(ppiInfo);
        }

        // Load current calibration on page load
        function loadCurrentCalibration() {
            fetch('/api/calibration')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        updateCalibrationStatus({
                            pixels_per_inch: data.calibration.calibrated_pixels_per_inch,
                            tags_used: data.calibration.tags_used
                        });
                    }
                })
                .catch(error => console.log('No previous calibration found'));
        }

        function createObjectElement(obj) {
            const div = document.createElement('div');
            div.className = 'tag-item';
            
            div.innerHTML = `
                <div class="tag-id">${obj.class_name} (${obj.confidence.toFixed(3)})</div>
                <div class="tag-info">
                    <span><strong>Class:</strong> ${obj.class_name}</span>
                    <span><strong>Confidence:</strong> ${obj.confidence.toFixed(3)}</span>
                    <span><strong>Center:</strong> (${Math.round(obj.center[0])}, ${Math.round(obj.center[1])})</span>
                    <span><strong>Size:</strong> ${Math.round(obj.width)}×${Math.round(obj.height)}</span>
                    <span><strong>X1:</strong> ${Math.round(obj.bbox[0])}</span>
                    <span><strong>Y1:</strong> ${Math.round(obj.bbox[1])}</span>
                    <span><strong>X2:</strong> ${Math.round(obj.bbox[2])}</span>
                    <span><strong>Y2:</strong> ${Math.round(obj.bbox[3])}</span>
                </div>
                <div class="coordinates">
                    BBox: [${obj.bbox.map(v => Math.round(v)).join(', ')}]<br>
                    Center: [${Math.round(obj.center[0])}, ${Math.round(obj.center[1])}]<br>
                    Size: ${Math.round(obj.width)} × ${Math.round(obj.height)} px
                </div>
            `;
            
            return div;
        }

        // Object Detection Controls
        function toggleObjectDetection() {
            const toggle = document.getElementById('objectDetectionToggle');
            const config = document.getElementById('objectDetectionConfig');
            
            if (toggle.checked) {
                config.style.display = 'block';
            } else {
                config.style.display = 'none';
            }
            
            socket.emit('toggle_object_detection', {enabled: toggle.checked});
        }

        function updateConfidence(value) {
            document.getElementById('confidenceValue').textContent = value;
        }

        function updateNMS(value) {
            document.getElementById('nmsValue').textContent = value;
        }

        function applyDetectionConfig() {
            const confidence = parseFloat(document.getElementById('confidenceSlider').value);
            const nms = parseFloat(document.getElementById('nmsSlider').value);
            
            fetch('/api/object_detection/config', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    confidence_threshold: confidence,
                    nms_threshold: nms
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showNotification('Settings Updated', data.message, 'success');
                } else {
                    showNotification('Update Failed', data.message, 'error');
                }
            })
            .catch(error => {
                showNotification('Update Failed', 'Network error', 'error');
            });
        }

        function loadObjectDetectionStatus() {
            fetch('/api/object_detection/status')
                .then(response => response.json())
                .then(data => {
                    updateObjectDetectionUI(data);
                })
                .catch(error => console.log('Failed to load object detection status'));
        }

        function updateObjectDetectionUI(data) {
            const toggle = document.getElementById('objectDetectionToggle');
            const statusText = document.getElementById('detectionStatusText');
            const confidenceSlider = document.getElementById('confidenceSlider');
            const nmsSlider = document.getElementById('nmsSlider');
            const confidenceValue = document.getElementById('confidenceValue');
            const nmsValue = document.getElementById('nmsValue');
            
            if (data.available) {
                statusText.textContent = data.enabled ? 'Enabled' : 'Available';
                statusText.style.color = data.enabled ? '#22c55e' : '#64748b';
                toggle.checked = data.enabled;
                
                if (data.enabled) {
                    document.getElementById('objectDetectionConfig').style.display = 'block';
                    
                    // Update inference button state
                    updateInferenceButtons(data.inference_running || false);
                    updateInferenceStatus(data.inference_running || false);
                }
                
                confidenceSlider.value = data.confidence_threshold;
                nmsSlider.value = data.nms_threshold;
                confidenceValue.textContent = data.confidence_threshold;
                nmsValue.textContent = data.nms_threshold;
            } else {
                statusText.textContent = 'Not Available';
                statusText.style.color = '#ef4444';
                toggle.disabled = true;
                
                // Disable inference controls if model not available
                updateInferenceButtons(false);
                updateInferenceStatus(false, 'Model not available');
            }
        }

        function updateObjectDetectionStatus(data) {
            const statusText = document.getElementById('detectionStatusText');
            if (data.enabled) {
                statusText.textContent = 'Enabled';
                statusText.style.color = '#22c55e';
                document.getElementById('objectDetectionConfig').style.display = 'block';
                
                // Update inference buttons based on current state
                if (data.inference_running !== undefined) {
                    updateInferenceButtons(data.inference_running);
                    updateInferenceStatus(data.inference_running);
                }
            } else {
                statusText.textContent = data.available ? 'Available' : 'Not Available';
                statusText.style.color = data.available ? '#64748b' : '#ef4444';
                document.getElementById('objectDetectionConfig').style.display = 'none';
                
                // Reset inference state when object detection is disabled
                updateInferenceButtons(false);
                updateInferenceStatus(false);
            }
        }

        // ML Inference Control Functions
        function startMLInference() {
            const startBtn = document.getElementById('startInferenceBtn');
            startBtn.disabled = true;
            startBtn.textContent = 'Starting...';
            
            socket.emit('start_ml_inference');
        }

        function stopMLInference() {
            const stopBtn = document.getElementById('stopInferenceBtn');
            stopBtn.disabled = true;
            stopBtn.textContent = 'Stopping...';
            
            socket.emit('stop_ml_inference');
        }

        function updateInferenceButtons(running) {
            const startBtn = document.getElementById('startInferenceBtn');
            const stopBtn = document.getElementById('stopInferenceBtn');
            
            if (running) {
                startBtn.style.display = 'none';
                stopBtn.style.display = 'block';
                stopBtn.disabled = false;
                stopBtn.textContent = 'Stop Inference';
            } else {
                startBtn.style.display = 'block';
                startBtn.disabled = false;
                startBtn.textContent = 'Start Inference';
                stopBtn.style.display = 'none';
            }
        }

        function updateInferenceStatus(running, errorMessage = null) {
            const statusDiv = document.getElementById('inferenceStatus');
            
            if (errorMessage) {
                statusDiv.textContent = errorMessage;
                statusDiv.style.color = '#ef4444';
            } else if (running) {
                statusDiv.textContent = 'ML inference running...';
                statusDiv.style.color = '#22c55e';
            } else {
                statusDiv.textContent = 'Ready to start ML inference';
                statusDiv.style.color = '#64748b';
            }
        }

        // Panel toggle functionality
        function togglePanel(panelId) {
            const header = document.querySelector(`[onclick="togglePanel('${panelId}')"]`);
            const content = document.getElementById(panelId);
            const chevron = header.querySelector('.panel-chevron');
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                header.classList.add('collapsed');
                chevron.classList.remove('expanded');
            } else {
                content.classList.add('expanded');
                header.classList.remove('collapsed');
                chevron.classList.add('expanded');
                
                // Load cameras when opening panel
                if (panelId === 'cameraOptions') {
                    loadCameras();
                }
            }
        }

        // Load available cameras
        function loadCameras() {
            fetch('/api/cameras')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        displayCameras(data.cameras, data.current_camera);
                    } else {
                        document.getElementById('cameraList').innerHTML = 
                            '<div style="text-align: center; color: #ef4444; padding: 20px;">Failed to load cameras</div>';
                    }
                })
                .catch(error => {
                    console.error('Error loading cameras:', error);
                    document.getElementById('cameraList').innerHTML = 
                        '<div style="text-align: center; color: #ef4444; padding: 20px;">Error loading cameras</div>';
                });
        }

        // Display camera list
        function displayCameras(cameras, currentCamera) {
            const cameraList = document.getElementById('cameraList');
            
            if (cameras.length === 0) {
                cameraList.innerHTML = 
                    '<div style="text-align: center; color: #64748b; padding: 20px;">No cameras found</div>';
                return;
            }
            
            cameraList.innerHTML = '';
            
            cameras.forEach(camera => {
                const cameraItem = document.createElement('div');
                cameraItem.className = `camera-item ${camera.is_current ? 'active' : ''}`;
                
                cameraItem.innerHTML = `
                    <div class="camera-info">
                        <div class="camera-name">
                            ${camera.name}
                            ${camera.is_current ? '<span class="current-badge">Current</span>' : ''}
                        </div>
                        <div class="camera-details">${camera.resolution} • ${camera.fps} FPS</div>
                    </div>
                    <div class="camera-actions">
                        ${!camera.is_current ? `<button class="btn btn-small primary" onclick="switchCamera(${camera.index})">Switch</button>` : ''}
                    </div>
                `;
                
                cameraList.appendChild(cameraItem);
            });
        }

        // Switch camera
        function switchCamera(cameraIndex) {
            socket.emit('switch_camera', { camera_index: cameraIndex });
        }

        // Refresh camera list
        function refreshCameras() {
            const refreshBtn = document.querySelector('button[onclick="refreshCameras()"]');
            const originalText = refreshBtn.textContent;
            refreshBtn.disabled = true;
            refreshBtn.textContent = 'Refreshing...';
            
            loadCameras();
            
            setTimeout(() => {
                refreshBtn.disabled = false;
                refreshBtn.textContent = originalText;
            }, 2000);
        }

        // Manual Measurement Functionality
        let measurementMode = false;
        let isDrawing = false;
        let startPoint = null;
        let canvas = null;
        let ctx = null;
        let isCalibrated = false;

        function toggleMeasurement() {
            measurementMode = !measurementMode;
            const btn = document.getElementById('measureBtn');
            const panel = document.getElementById('measurementPanel');
            const videoContainer = document.querySelector('.video-container');
            
            if (measurementMode) {
                btn.textContent = '📏 Exit Measure';
                btn.classList.add('primary');
                panel.style.display = 'block';
                setupMeasurementCanvas();
                videoContainer.style.cursor = 'crosshair';
            } else {
                btn.textContent = '📏 Measure';
                btn.classList.remove('primary');
                panel.style.display = 'none';
                clearMeasurement();
                videoContainer.style.cursor = 'default';
                if (canvas) {
                    canvas.style.pointerEvents = 'none';
                }
            }
        }

        function setupMeasurementCanvas() {
            canvas = document.getElementById('measurementCanvas');
            const videoFeed = document.getElementById('videoFeed');
            
            // Match canvas size to video
            canvas.width = videoFeed.offsetWidth;
            canvas.height = videoFeed.offsetHeight;
            canvas.style.width = videoFeed.offsetWidth + 'px';
            canvas.style.height = videoFeed.offsetHeight + 'px';
            canvas.style.pointerEvents = 'auto';
            
            ctx = canvas.getContext('2d');
            
            // Add event listeners
            canvas.addEventListener('mousedown', startMeasurement);
            canvas.addEventListener('mousemove', updateMeasurement);
            canvas.addEventListener('mouseup', endMeasurement);
        }

        function startMeasurement(e) {
            if (!measurementMode || !isCalibrated) return;
            
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            startPoint = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
            
            clearCanvas();
        }

        function updateMeasurement(e) {
            if (!isDrawing || !measurementMode) return;
            
            const rect = canvas.getBoundingClientRect();
            const currentPoint = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
            
            clearCanvas();
            drawMeasurementLine(startPoint, currentPoint);
        }

        function endMeasurement(e) {
            if (!isDrawing || !measurementMode) return;
            
            isDrawing = false;
            const rect = canvas.getBoundingClientRect();
            const endPoint = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
            
            calculateMeasurement(startPoint, endPoint);
        }

        function drawMeasurementLine(start, end) {
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.stroke();
            
            // Draw start and end points
            ctx.fillStyle = '#3b82f6';
            ctx.beginPath();
            ctx.arc(start.x, start.y, 4, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(end.x, end.y, 4, 0, 2 * Math.PI);
            ctx.fill();
        }

        function calculateMeasurement(point1, point2) {
            // Scale points to actual video resolution (640x480)
            const videoFeed = document.getElementById('videoFeed');
            const scaleX = 640 / videoFeed.offsetWidth;
            const scaleY = 480 / videoFeed.offsetHeight;
            
            const scaledPoint1 = {
                x: point1.x * scaleX,
                y: point1.y * scaleY
            };
            const scaledPoint2 = {
                x: point2.x * scaleX,
                y: point2.y * scaleY
            };
            
            fetch('/api/measure', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    point1: scaledPoint1,
                    point2: scaledPoint2
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    displayMeasurementResults(data.measurement);
                } else {
                    showNotification('Measurement Error', data.message, 'error');
                }
            })
            .catch(error => {
                showNotification('Measurement Error', 'Network error', 'error');
            });
        }

        function displayMeasurementResults(measurement) {
            const isMetric = document.querySelector('input[name="measurementUnit"]:checked').value === 'metric';
            const resultsDiv = document.getElementById('measurementResults');
            const valuesDiv = document.getElementById('measurementValues');
            
            let displayText = '';
            if (isMetric) {
                if (measurement.cm_distance > 100) {
                    displayText = `<strong>${(measurement.cm_distance / 100).toFixed(2)} m</strong>`;
                } else {
                    displayText = `<strong>${measurement.mm_distance.toFixed(1)} mm</strong>`;
                }
                displayText += `<br><span style="color: #64748b;">Alternative: ${measurement.inch_distance.toFixed(2)} inches</span>`;
            } else {
                if (measurement.inch_distance > 12) {
                    displayText = `<strong>${(measurement.inch_distance / 12).toFixed(2)} ft</strong>`;
                } else {
                    displayText = `<strong>${measurement.inch_distance.toFixed(2)} in</strong>`;
                }
                displayText += `<br><span style="color: #64748b;">Alternative: ${measurement.cm_distance.toFixed(1)} cm</span>`;
            }
            
            valuesDiv.innerHTML = displayText;
            resultsDiv.style.display = 'block';
            
            // Update overlay info
            const overlayInfo = document.getElementById('measurementInfo');
            const overlayText = document.getElementById('measurementText');
            overlayText.innerHTML = displayText.replace('<br>', ' / ');
            overlayInfo.style.display = 'block';
        }

        function clearMeasurement() {
            if (canvas && ctx) {
                clearCanvas();
            }
            document.getElementById('measurementResults').style.display = 'none';
            document.getElementById('measurementInfo').style.display = 'none';
        }

        function clearCanvas() {
            if (ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }

        function updateCalibrationStatus(calibrationData) {
            isCalibrated = true;
            const measureBtn = document.getElementById('measureBtn');
            const calibrationStatus = document.getElementById('calibrationStatus');
            
            measureBtn.disabled = false;
            measureBtn.title = 'Click to start measuring distances';
            
            calibrationStatus.style.background = '#f0fdf4';
            calibrationStatus.style.color = '#15803d';
            calibrationStatus.style.borderColor = '#bbf7d0';
            calibrationStatus.innerHTML = `✅ Camera calibrated. PPI: ${calibrationData.pixels_per_inch.toFixed(2)}`;
        }

        function loadCurrentCalibration() {
            fetch('/api/calibration')
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.calibration) {
                        updateCalibrationStatus(data.calibration);
                    }
                })
                .catch(error => console.log('No existing calibration found'));
        }

        // Auto-refresh tag data
        setInterval(() => {
            if (isDetecting) {
                socket.emit('get_frame');
            }
        }, 100); // 10 FPS for tag data updates

        // Start detection automatically and load calibration
        window.addEventListener('load', () => {
            setTimeout(startDetection, 1000);
            loadCurrentCalibration();
            loadObjectDetectionStatus();
        });
    </script>
</body>
</html>